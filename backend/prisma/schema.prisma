generator client {
  provider = "prisma-client-js"
}

// datasource db {
//   provider = "postgresql"
//   url      = env("DATABASE_URL")
// }
datasource db {
  provider  = "postgresql"
  url  	    = env("DATABASE_URL")
  // uncomment next line if you use Prisma <5.10
  directUrl = env("DATABASE_URL_UNPOOLED")
}

model User {
  id                 Int                  @id @default(autoincrement())
  email              String               @unique
  password           String
  name               String
  isAdmin            Boolean              @default(false)
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  refreshToken       String?
  employeeId         String?              @unique @map("employee_id")
  cardNumber         String?              @map("card_number")
  validFrom          DateTime?            @map("valid_from")
  validTo            DateTime?            @map("valid_to")
  epfNo              String?              @map("epfNo")
  nic                String?              @map("NIC")
  jobPosition        String?              @map("jobPosition")
  imagePath          String?
  active             Boolean              @default(true)

  leaveRequests    Leave_request[] @relation("UserLeaveRequests")
  approvedRequests Leave_request[] @relation("ApprovedRequests")

  leaveBalances      Leave_balance[]
  punches            Punch[]
  attendanceDays     AttendanceDay[]

  @@map("users")
}

model Leave_request {
  id          Int                  @id @default(autoincrement())
  userId      Int
  approvedBy  Int?
  leaveType   LeaveType
  status      LeaveStatus?         @default(PENDING)
  reason      String?
  requestedAt DateTime             @default(now())
  approvedAt  DateTime?
  rejectedAt  DateTime?
  dates       Leave_request_date[]

  user           User @relation("UserLeaveRequests", fields: [userId], references: [id], onDelete: Cascade)
  approvedByUser User? @relation("ApprovedRequests", fields: [approvedBy], references: [id])

  @@map("leave_requests")
}

model Leave_request_date {
  id          Int           @id @default(autoincrement())
  requestId   Int
  leaveDate   DateTime
  isHalfDay   Boolean       @default(false)
  halfdayType HalfdayType?
  request     Leave_request @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@map("leave_request_dates")
}

model Leave_balance {
  id        Int       @id @default(autoincrement())
  userId    Int
  year      Int
  leaveType LeaveType
  balance   Float

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, year, leaveType])
  @@map("leave_balances")
}

model Leave_policy {
  leaveType      LeaveType @id
  defaultBalance Float

  @@map("leave_policies")
}

model SyncHistory {
  id           Int      @id @default(autoincrement())
  syncTime     DateTime @default(now()) @map("sync_time")
  totalUsers   Int      @map("total_users")
  newUsers     Int      @map("new_users")
  updatedUsers Int      @map("updated_users")
  status       String

  @@map("sync_history")
}

model Punch {
  id Int                        @id @default(autoincrement())
  employeeId String             @map("employee_id")
  eventTime DateTime            @map("event_time") @db.Timestamptz(0)
  correctEventTime DateTime?    @map("correct_event_time") @db.Timestamptz(0) // NEW (nullable for backfill)
  direction Direction
  source Source
  note String?
  createdBy String?             @map("created_by")
  createdAt DateTime            @default(now()) @map("created_at") @db.Timestamptz(0)
  deletedAt DateTime?           @map("deleted_at") @db.Timestamptz(0)
  directionCorrected Boolean    @default(false) @map("direction_corrected")
  originalDirection Direction?  @map("original_direction")
  correctedBy String?           @map("corrected_by")
  correctionNote String?        @map("correction_note")
  correctedAt DateTime?         @map("corrected_at") @db.Timestamptz(0)

  user User                     @relation(fields: [employeeId], references: [employeeId], onDelete: Cascade)
  @@unique([employeeId, eventTime, direction, source])
  @@index([employeeId, eventTime])
  @@index([employeeId, correctEventTime])
  @@map("punches")
}

model AttendanceDay {
  employeeId        String           @map("employee_id")
  workDate          DateTime         @map("work_date")
  startTime         String?          @map("start_time")
  firstIn           String?          @map("first_in")
  lastOut           String?          @map("last_out")
  workedSeconds     Int              @default(0) @map("worked_seconds")
  notWorkingSeconds Int              @default(0) @map("not_working_seconds")
  overtimeSeconds   Int              @default(0) @map("overtime_seconds")
  hadManual         Boolean          @default(false) @map("had_manual")
  status            AttendanceStatus @default(OK)
  calculatedAt      DateTime         @default(now()) @map("calculated_at")

  user User @relation(fields: [employeeId], references: [employeeId], onDelete: Cascade)

  @@id([employeeId, workDate])
  @@index([workDate])
  @@map("attendance_day")
}

model DeviceConfig {
  id               Int       @id
  ip               String
  username         String
  passwordEnc      String
  lastEventTime    String?
  authFailedAt     DateTime? // When auth last failed
  authFailureCount Int       @default(0) // Number of consecutive failures
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@map("device_configs")
}

model AttendanceConfig {
  id          Int      @id @default(autoincrement())
  workStart   DateTime
  workEnd     DateTime
  otEnd       DateTime
  earlyStart  DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("attendance_config")
}


enum LeaveType {
  ANNUAL
  CASUAL
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum HalfdayType {
  MORNING
  AFTERNOON
}

enum Direction {
  IN
  OUT
}

enum Source {
  device
  manual
}

enum AttendanceStatus {
  OK
  ABSENT
  PARTIAL
  MANUAL
}